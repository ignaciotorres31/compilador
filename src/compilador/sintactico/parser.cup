package compilador.sintactico;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;

class MiParser;


parser code
{:
    public Hashtable ht = new Hashtable();
    public void tabla_simbolos(Hashtable ht){
            ht.forEach((k, v) -> {  
            System.out.println("Tabla de simbolos: " + k.toString() + " " + v.toString());
        });
            
    }
    
    public void syntax_error(Symbol s){
        System.out.println(" Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println(" Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

:};


terminal SUMA, RESTA, MULTIPLICACION, DIVISION,IGUAL, IGUAL_IGUAL, DESIGUAL, MAYOR, MAYOR_IGUAL, MENOR,
MENOR_IGUAL, PARENTESISA, PARENTESISC, CORCHETESA, CORCHETESC,  COMA, PUNTOCOMA, DOS_PUNTOS;

terminal String IDENTIFICADOR, BOOLEAN_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL,SUMAIMPAR, INTEGER, FLOAT, BOOLEAN, 
INPUT_INT, INPUT_FLOAT, INPUT_BOOL, AND, OR, NOT, WHILE, DO, END,IF, THEN, ELSE, DISPLAY, DECLARE_SECTION, 
ENDDECLARE_SECTION, PROGRAM_SECTION, ENDPROGRAM_SECTION;

nonterminal String programa, bloque_declaraciones, bloque_programa, declaraciones,declaracion, 
bloque_sentencias, sentencia, sentencia_while, sentencia_if, sentencia_asignacion, sentencia_display, factor, 
expresion_or, expresion_and, expresion_not, comparacion, expresion_sr, expresion_md, menos_unario, funcion_especial,
lista_expresiones, input, display, input_int, input_float, input_bool, impresion;

nonterminal List<String>  tipos_datos_id;

start with impresion;

impresion ::= programa: prog{:
        RESULT = new Impresion(prog);
        :}

programa ::= bloque_declaraciones:bd bloque_programa: bp{:
            RESULT = new ProgramaCompleto(bd,bp);
        :}
        |
        bloque_declaraciones:bd {:
            RESULT = new Bloque(bd);
        :}
        |
        bloque_programa: bp{:
            RESULT = new Programa(bp);
        :};

bloque_declaraciones ::= DECLARE_SECTION declaraciones:d ENDDECLARE_SECTION{:
            RESULT = "DECLARE_SECTION" + d + "ENDDECLARE_SECTION";
        :};

declaraciones ::= declaracion:dec declaraciones:decs{:
            RESULT = dec + decs;
        :}
        |
        declaracion:dec{:
            RESULT = dec;
        :};


declaracion ::= FLOAT:f DOS_PUNTOS tipos_datos_id:tdi PUNTOCOMA{:
            for(String i : tdi){
                ht.put(i,f);}
            RESULT = new Tipo(f)+"DOS_PUNTOS"+ tdi +"PUNTOCOMA";
        :}
        | 
        INTEGER:in DOS_PUNTOS tipos_datos_id:tdi PUNTOCOMA{:
            for(String i : tdi){
                ht.put(i,in);}
            RESULT = new Tipo(in) +"DOS_PUNTOS"+ tdi +"PUNTOCOMA";
        :}
        | 
        BOOLEAN:b DOS_PUNTOS tipos_datos_id:tdi PUNTOCOMA{:
            for(String i : tdi){
                ht.put(i,b);}
            RESULT = new Tipo(b) +"DOS_PUNTOS"+ tdi +"PUNTOCOMA";
        :};

tipos_datos_id ::= IDENTIFICADOR:id{:
            List<String> ident = new ArrayList<String>();
            ident.add(id);
            RESULT = ident;
        :}
        |
        tipos_datos_id: tdi COMA IDENTIFICADOR:id {:
            tdi.add(id);
            RESULT = tdi;

        :};

bloque_programa ::= PROGRAM_SECTION bloque_sentencias:bs ENDPROGRAM_SECTION{:
            RESULT = "PROGRAM_SECTION" + bs + "ENDPROGRAM_SECTION";
        :};

bloque_sentencias ::= bloque_sentencias:bs sentencia:s {:
            RESULT =bs + s;
        :}
        | 
        sentencia:s {:
            RESULT = s;
        :};  

sentencia ::= sentencia_while: sw{:
            RESULT = sw;
        :}
        |
        sentencia_if: si{:
            RESULT = si;
        :}
        |
        sentencia_asignacion: sa{:
            RESULT = sa;
        :}
        |   
        sentencia_display: sd{:
            RESULT = sd;
        :};

sentencia_asignacion ::= IDENTIFICADOR:id IGUAL expresion_or: eo {:
            RESULT = new Asignacion(id,eo) ;
        :}
        |
        IDENTIFICADOR:id IGUAL funcion_especial: fe {:
            RESULT = new Asignacion(id,fe) ;
        :};

expresion_or ::= expresion_or: eo OR expresion_and :ea{:
            RESULT =new Conjuncion(eo,ea) ;
        :}
        |
        expresion_and :ea{:
            RESULT = ea;
        :};

expresion_and ::= expresion_and: ea AND expresion_not :en{:
            RESULT = new Disyuncion(ea,en);
        :}
        |
        expresion_not :en{:
            RESULT = en;
        :};

expresion_not ::= NOT expresion_not :en{:
            RESULT =new NegacionLogica(en);
        :}
        |
        comparacion:c{:
            RESULT = c;
        :};

comparacion ::= expresion_sr :esr1 MAYOR expresion_sr: esr2{:
            RESULT = new Mayor(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MAYOR_IGUAL expresion_sr: esr2{:
            RESULT = new MayorIgual(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MENOR expresion_sr: esr2{:
            RESULT = new Menor(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MENOR_IGUAL expresion_sr: esr2{:
            RESULT = new MenorIgual(esr1,esr2);
        :}
        |
        expresion_sr :esr1 IGUAL_IGUAL expresion_sr: esr2{:
            RESULT = new Igualdad(esr1,esr2);
        :}
        |
        expresion_sr :esr1 DESIGUAL expresion_sr: esr2{:
            RESULT = new Desigualdad(esr1,esr2);
        :}
        |
        expresion_sr :esr{:
            RESULT = esr;
        :};

expresion_sr ::= expresion_sr :esr SUMA expresion_md: emd{:
            RESULT = new Suma(esr,emd);
        :}
        |
        expresion_sr :esr RESTA expresion_md: emd{:
            RESULT = new Resta(esr,emd);
        :}
        |
        expresion_md :emd{:
            RESULT = emd;
        :};

expresion_md ::= expresion_md :emd MULTIPLICACION menos_unario:mu{:
            RESULT = new Multiplicacion(emd,mu);
        :}
        |
        expresion_md :emd DIVISION menos_unario:mu{:
            RESULT = new Division(emd,mu) ;
        :}
        |
        menos_unario:mu{:
            RESULT = mu;
        :};

menos_unario ::= RESTA menos_unario:mu{:
            RESULT =  new NegacionAritmetica(mu) ;
        :}
        |
        factor:f {:
            RESULT = f ;
        :};

factor ::= BOOLEAN_LITERAL:bl{:
            RESULT = new Booleano(bl);
        :}
        |
        INTEGER_LITERAL:il{:
            RESULT = new Entero(il);
        :}
        |
        FLOAT_LITERAL:fl{:
            RESULT = new Flotante(fl);
        :}
        |
        PARENTESISA expresion_or:eo PARENTESISC{:
            RESULT = "(" + eo + ")";
        :}
        |
        IDENTIFICADOR:id{:
            RESULT = id;
        :};

funcion_especial ::= SUMAIMPAR:sim PARENTESISA INTEGER_LITERAL:il PUNTOCOMA CORCHETESA lista_expresiones:le CORCHETESC PARENTESISC{:
            RESULT = sim + "(" + il + ";"+ "[" + le + "]" + ")";
        :};

lista_expresiones ::= lista_expresiones:le COMA expresion_sr:esr{:
            RESULT = le + ","+ esr;
        :}
        |
        expresion_sr:esr{:
            RESULT = esr ;
        :}
        |
        {::};

sentencia_while ::= WHILE PARENTESISA condicion:c PARENTESISC DO bloque_sentencias:bs END{:
            RESULT = new Mientras(c,bs);
        :};

condicion ::= expresion_sr :esr1 MAYOR expresion_sr: esr2{:
            RESULT = new Mayor(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MAYOR_IGUAL expresion_sr: esr2{:
            RESULT = new MayorIgual(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MENOR expresion_sr: esr2{:
            RESULT = new Menor(esr1,esr2);
        :}
        |
        expresion_sr :esr1 MENOR_IGUAL expresion_sr: esr2{:
            RESULT = new MenorIgual(esr1,esr2);
        :}
        |
        expresion_sr :esr1 IGUAL_IGUAL expresion_sr: esr2{:
            RESULT = new Igualdad(esr1,esr2);
        :}
        |
        expresion_sr :esr1 DESIGUAL expresion_sr: esr2{:
            RESULT = new Desigualdad(esr1,esr2);
        :};

sentencia_display ::= display:d {:
            RESULT = d;
        :}
        |
        input:i {:
            RESULT = i;
        :};

display ::= DISPLAY PARENTESISA expresion_or:eo PARENTESISC{:
            RESULT = "DISPLAY" +"("+eo+")";
        :};

input ::= input_int:ii {:
            RESULT = ii;
        :}
        |
        input_float:ifl {:
            RESULT = ifl;
        :}
        |
        input_bool:ib {:
            RESULT = ib;
        :};

input_int ::= INPUT_INT PARENTESISA PARENTESISC {:
            RESULT = "INPUT_INT"+"(" +")";
        :};

input_float ::= INPUT_FLOAT PARENTESISA PARENTESISC {:
            RESULT = "INPUT_FLOAT"+"("+")";
        :};

input_bool ::= INPUT_BOOL PARENTESISA PARENTESISC {:
            RESULT = "INPUT_BOOL"+"("+")";
        :};

sentencia_if ::= IF PARENTESISA expresion_or:eo PARENTESISC THEN bloque_sentencias:bs END{:
            RESULT = "IF" + "("+ eo + ")"+"THEN"+bs+"END";
        :}
        |
        IF PARENTESISA expresion_or:eo PARENTESISC THEN bloque_sentencias:bs1 ELSE bloque_sentencias:bs2 END{:
            RESULT = "IF" + "("+ eo + ")"+"THEN"+bs1+"ELSE"+bs2+"END";
        :};